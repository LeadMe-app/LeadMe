import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  Alert,
  Platform,
} from 'react-native';
import { Picker } from '@react-native-picker/picker';
import styles from './styles';
import Logo from '../../components/Logo';
import Speaker from '../../icons/Speaker_icons.svg';
import Micro from '../../icons/microphone_icons.svg';
import Stop from '../../icons/stop_icons.svg';
import Play from '../../icons/play_icons.svg';
import axiosInstance from '../../config/axiosInstance';
import AsyncStorage from '@react-native-async-storage/async-storage';
import Sound from 'react-native-sound';
import AudioRecorderPlayer from 'react-native-audio-recorder-player';
import SentenceModal from '../../components/SentenceModal';

const SentenceSpeech = ({ navigation }) => {
  const [modalVisible, setModalVisible] = useState(false);
  const [isPracticing, setIsPracticing] = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  const [sentence, setSentence] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [recordedPath, setRecordedPath] = useState('');
  const [selectedSpeed, setSelectedSpeed] = useState('');
  const [highlightIndex, setHighlightIndex] = useState(-1);
  const [ageGroup, setAgeGroup] = useState('20ÏÑ∏ Ïù¥ÏÉÅ');
  const [isAnimating, setIsAnimating] = useState(false);
  const [isManualRecording, setIsManualRecording] = useState(false); // 
  
  const intervalRef = useRef(null);
  const audioRecorderPlayer = useRef(null);

  const [isTTSPlaying, setIsTTSPlaying] = useState(false);
  const ttsSoundRef = useRef(null);
  const karaokeIndexRef = useRef(0);

   useEffect(() => {
    audioRecorderPlayer.current = new AudioRecorderPlayer();

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);
  const getDelayFromSPS = (sps) => Math.round((1000 / sps) * 0.9);
  // ÏÜçÎèÑ Îß§Ìïë (Î∞ÄÎ¶¨Ï¥à Îã®ÏúÑ)
  const speedMap = {
  '5~12ÏÑ∏': {
    ÎäêÎ¶º: getDelayFromSPS(2.5),      // ÎäêÎ¶º ÌõàÎ†®Ïö©
    ÌèâÍ∑†: getDelayFromSPS(3.5),      // ÌèâÍ∑†: ÏùºÎ∞ò ÏïÑÎèô ÏÜçÎèÑ
    Ï°∞Í∏àÎπ†Î¶Ñ: getDelayFromSPS(4.0),  // ÌèâÍ∑†ÏùÑ Ìñ•Ìïú ÌõàÎ†®
    Îπ†Î¶Ñ: getDelayFromSPS(5.0),      // ÏÜçÌôîÏ¶ù ÎßêÌïòÍ∏∞ ÏàòÏ§Ä
  },
  '13~19ÏÑ∏': {
    ÎäêÎ¶º: getDelayFromSPS(3.0),
    ÌèâÍ∑†: getDelayFromSPS(4.5),
    Ï°∞Í∏àÎπ†Î¶Ñ: getDelayFromSPS(5.0),
    Îπ†Î¶Ñ: getDelayFromSPS(6.0),
  },
  '20ÏÑ∏ Ïù¥ÏÉÅ': {
    ÎäêÎ¶º: getDelayFromSPS(3.5),
    ÌèâÍ∑†: getDelayFromSPS(5.0),
    Ï°∞Í∏àÎπ†Î¶Ñ: getDelayFromSPS(5.5),
    Îπ†Î¶Ñ: getDelayFromSPS(6.5),
  },
};

  // Î¨∏Ïû•ÏùÑ ÏùåÏ†à Îã®ÏúÑÎ°ú Ï™ºÍ∞¨
  const syllables = Array.from(sentence);
  const karaokeActiveRef = useRef(0);

  // ÎÖ∏ÎûòÎ∞© Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
  const startKaraokeAnimation = () => {
    karaokeActiveRef.current = true;
    if (intervalRef.current) clearInterval(intervalRef.current);
    setHighlightIndex(0);
    setIsAnimating(true);

    const delay = (speedMap[ageGroup] && speedMap[ageGroup][selectedSpeed]) || 300;
    karaokeIndexRef.current = 0;

    const animate = () => {
      if (!karaokeActiveRef.current) return; 
      intervalRef.current = setInterval(() => {
        if (!karaokeActiveRef.current) {
          clearInterval(intervalRef.current);
          return;
        }

        if (karaokeIndexRef.current >= syllables.length) {
          clearInterval(intervalRef.current);
          setTimeout(() => {
            if (karaokeActiveRef.current) {
              karaokeIndexRef.current = 0;
              setHighlightIndex(0);
              animate(); // Î∞òÎ≥µ
            }
          }, 1000);
        } else {
          setHighlightIndex(karaokeIndexRef.current);
          karaokeIndexRef.current += 1;
        }
      }, delay);
    };
    animate();
  };

  // ÎÖ∏ÎûòÎ∞© Ïï†ÎãàÎ©îÏù¥ÏÖò Ï¢ÖÎ£å
  const stopKaraokeAnimation = () => {
    karaokeActiveRef.current = false;
    if (intervalRef.current) clearInterval(intervalRef.current);
    setHighlightIndex(-1);
    setIsAnimating(false);
  };

  // Ïó∞Ïäµ ÏãúÏûë/Ï¢ÖÎ£å ÌÜ†Í∏Ä (ÎÖπÏùå + ÎÖ∏ÎûòÎ∞© Ìö®Í≥º ÎèôÏãú)
  const handlePracticeToggle = async () => {
     if (!selectedSpeed || selectedSpeed.trim() === '') {
      Alert.alert('ÏïåÎ¶º', 'Î®ºÏ†Ä ÏÜçÎèÑÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
      return;
    }
    if (!isPracticing) {
      try {
        const result = await audioRecorderPlayer.current.startRecorder();
        audioRecorderPlayer.current.addRecordBackListener(() => {});
        setRecordedPath(result);
        setIsRecording(true);
        setIsPracticing(true);

        startKaraokeAnimation();
      } catch (e) {
        console.error('ÎÖπÏùå ÏãúÏûë Ïã§Ìå®:', e);
        Alert.alert('Ïò§Î•ò', 'ÎÖπÏùå ÏãúÏûëÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
      }
    } else {
      await stopPractice();
    }
  };

  const handlePlayPress = async () => {
    if (recordedPath) {
      const path =
        Platform.OS === 'android'
          ? recordedPath.replace('file://', '')
          : recordedPath;
      console.log('Ïû¨ÏÉùÌï† Í≤ΩÎ°ú', path);

      const sound = new Sound(path, '', (error) => {
        if (error) {
          console.log('Ïû¨ÏÉù Ï¥àÍ∏∞Ìôî Ïã§Ìå®', error);
          return;
        }
        sound.play((success) => {
          if (success) {
            console.log('Ïû¨ÏÉù ÏôÑÎ£å');
          } else {
            console.log('Ïû¨ÏÉù Ï§ë Ïò§Î•ò Î∞úÏÉù');
          }
        });
      });
    }
  };

  // Î¨∏Ïû• Î∂àÎü¨Ïò§Í∏∞
  const fetchSentence = async () => {
    try {
      const userId = await AsyncStorage.getItem('userId');
      const response = await axiosInstance.post('/api/sentence/generate', {
        user_id: userId,
      });

      if (response.data.sentence) {
        const cleanedSentence = response.data.sentence.replace(/^"(.*)"$/, '$1').replace(/[!,.?"'Ôºå„ÄÇÔºÅÔºü„ÄÅ]/g, '');;
        setSentence(cleanedSentence);
      } else {
        Alert.alert('Ïò§Î•ò', 'Î¨∏Ïû•ÏùÑ Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.');
      }
    } catch (error) {
      console.error('Î¨∏Ïû• Î∂àÎü¨Ïò§Í∏∞ Ïò§Î•ò:', error);
      Alert.alert('Ïò§Î•ò', 'Î¨∏Ïû•ÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    }
  };

  // Ïú†Ï†Ä Ïó∞Î†πÎåÄ AsyncStorageÏóêÏÑú Î∂àÎü¨Ïò§Í∏∞
  const fetchAgeGroup = async () => {
    const storedAgeGroup = await AsyncStorage.getItem('age_group');
    if (storedAgeGroup) {
      setAgeGroup(storedAgeGroup);
    }
  };

  useEffect(() => {
    fetchAgeGroup();
    fetchSentence();

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, []);

  // TTS ÏöîÏ≤≠ Î∞è Ïû¨ÏÉù (Í∏∞Ï°¥ ÏΩîÎìú Ïú†ÏßÄ)
  const requestTTSAndPlay = async () => {
    if (isTTSPlaying && ttsSoundRef.current) {
      // üîá Ïù¥ÎØ∏ Ïû¨ÏÉù Ï§ëÏù¥Î©¥ Ï†ïÏßÄ
      ttsSoundRef.current.stop(() => {
        console.log('TTS Ï†ïÏßÄ');
        ttsSoundRef.current.release();
        ttsSoundRef.current = null;
        setIsTTSPlaying(false);
      });
      return;
    }
    try {
      setIsProcessing(true);
      const userId = await AsyncStorage.getItem('userId');
      const token = await AsyncStorage.getItem('access_token');

      const params = new URLSearchParams({
        text: sentence,
        user_id: userId,
        speaker: 'Seoyeon',
        speed: 'Ï§ëÍ∞Ñ',
        age_group: '13ÏÑ∏~19ÏÑ∏', // Ïó∞Î†πÎåÄÎ°ú Î∞îÍæ∏Í∏∞
      });

      const response = await axiosInstance.post(
        `/api/tts/text-to-speech/?${params.toString()}`,
        {},
        { headers: { Authorization: `Bearer ${token}` } }
      );

      const { file_url } = response.data;
      if (!file_url) {
        Alert.alert('Ïò§Î•ò', 'ÏùåÏÑ± ÌååÏùº Í≤ΩÎ°úÎ•º Î∞õÏïÑÏò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.');
        return;
      }

      const fullUrl = `${axiosInstance.defaults.baseURL}${file_url}`;
      const sound = new Sound(fullUrl, null, (error) => {
        if (error) {
          console.error('TTS Î°úÎî© Ïã§Ìå®:', error);
          Alert.alert('Ïò§Î•ò', 'TTS Ïû¨ÏÉù Ïã§Ìå®');
          return;
        }
        ttsSoundRef.current = sound; 
        setIsTTSPlaying(true);   

        sound.play(() => {
          sound.release();
          ttsSoundRef.current = null;
          setIsTTSPlaying(false);  
        });
      });
    } catch (error) {
      console.error('TTS Ïò§Î•ò:', error);
      Alert.alert('TTS Ïã§Ìå®');
    } finally {
      setIsProcessing(false);
    }
  };

  const stopPractice = async () => {
    try {
      if (audioRecorderPlayer.current) {
        await audioRecorderPlayer.current.stopRecorder();
        audioRecorderPlayer.current.removeRecordBackListener();
      }
    } catch (e) {
      console.error('ÎÖπÏùå Ï¢ÖÎ£å Ïã§Ìå®:', e);
    } finally {
      setIsRecording(false);
      setIsPracticing(false);
      stopKaraokeAnimation();
    }
  };

  return (
    <View style={styles.container}>
      <Logo />
      <View style={{ flexDirection: 'row', flexWrap: 'wrap', marginVertical: 10 }}>
        {syllables.length > 0 ? (
          syllables.map((char, idx) => (
            <Text
              key={idx}
              style={{
                ...styles.sentence,
                color: idx === highlightIndex ? '#FF3B30' : '#000',
                fontWeight: idx === highlightIndex ? 'bold' : 'normal',
              }}
            >
              {char}
            </Text>
          ))
        ) : (
          <Text style={styles.sentence}>Î¨∏Ïû•ÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë...</Text>
        )}
      </View>
         <View style={styles.underline} />
      <View style={styles.topRow}>
        <TouchableOpacity onPress={requestTTSAndPlay} disabled={isProcessing}>
          <Speaker width={40} height={40} />
        </TouchableOpacity>

        <Picker
          selectedValue={selectedSpeed}
          onValueChange={(value) => setSelectedSpeed(value)}
          mode="dropdown"
          style={{
            ...styles.dropdown,
            color: '#000',
            fontFamily: undefined,
          }}
          itemStyle={{ color: '#000' }}
          enabled={!isPracticing}
        >
          <Picker.Item label="ÏõêÌïòÎäî ÏÜçÎèÑÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî" value=" " enabled={false}/>
          <Picker.Item label="ÎäêÎ¶º" value="ÎäêÎ¶º" />
          <Picker.Item label="ÌèâÍ∑†" value="ÌèâÍ∑†" />
          <Picker.Item label="Ï°∞Í∏àÎπ†Î¶Ñ" value="Ï°∞Í∏àÎπ†Î¶Ñ" />
          <Picker.Item label="Îπ†Î¶Ñ" value="Îπ†Î¶Ñ" />
        </Picker>
      </View>

      <TouchableOpacity
        style={isPracticing ? styles.stopButton : styles.startButton}
        onPress={handlePracticeToggle}
      >
        <Text style={styles.practiceButtonText}>
          {isPracticing ? 'Ïó∞Ïäµ Ï¢ÖÎ£å' : 'Ïó∞Ïäµ ÏãúÏûë'}
        </Text>
      </TouchableOpacity>

      <View style={styles.iconRow}>
        <TouchableOpacity disabled>
          {isRecording ? (
            <Stop width={50} height={50} />
          ) : (
            <Micro width={50} height={50} />
          )}
          <Text style={styles.iconLabel}>{isRecording ? 'ÎÖπÏùåÏ§ë' : 'ÎÖπÏùå'}</Text>
        </TouchableOpacity>

        <TouchableOpacity onPress={handlePlayPress} style={styles.iconWithLabel}>
          <Play width={50} height={50} />
          <Text style={styles.iconLabel}>Ïû¨ÏÉù</Text>
        </TouchableOpacity>
      </View>
      <View style={{ marginTop : '60' }}>
        <TouchableOpacity
          onPress={() => setModalVisible(true)}
          style={{
            backgroundColor: '#F8D7A9',
            paddingHorizontal: 12,
            paddingVertical: 6,
            borderRadius: 6,
          }}
        >
          <Text style={{ fontWeight: '500' }}>ÏÇ¨Ïö©Î∞©Î≤ï</Text>
        </TouchableOpacity>
      </View>
      {/* Î∂ÑÎ¶¨Ìïú Î™®Îã¨ Ïª¥Ìè¨ÎÑåÌä∏ */}
      <SentenceModal visible={modalVisible} onClose={() => setModalVisible(false)} />
            
      <View style={styles.bottomButtons}>
        <TouchableOpacity
          style={styles.endButton}
          onPress={async () => {
            if (isPracticing) await stopPractice(); // ‚Üê Ïó∞Ïäµ Ï§ëÏù¥Î©¥ Ï¢ÖÎ£å
            navigation.navigate('SelectSpeechTypeScreen');
          }}
        >
        <Text style={styles.bottomButtonText}>ÏπòÎ£å Ï¢ÖÎ£å</Text>
        </TouchableOpacity>
        
        <TouchableOpacity
          style={styles.otherButton}
          onPress={async () => {
            if (isPracticing) await stopPractice(); // ‚Üê Ïó∞Ïäµ Ï§ëÏù¥Î©¥ Ï¢ÖÎ£å
            fetchSentence();
          }}
        >
          <Text style={styles.bottomButtonText}>Îã§Î•∏ Î¨∏Ïû•</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};

export default SentenceSpeech;
